{"version":3,"file":"indexedDb.Blazor.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,kFAAiG;AAGjG,MAAa,gBAAgB;IAKzB;QAHQ,eAAU,GAAkC,SAAS,CAAC;QACtD,mBAAc,GAAG,CAAC,OAAe,EAAE,EAAE,GAAG,CAAC,CAAC;QAI3C,WAAM,GAAG,CAAO,IAAc,EAAE,eAAuC,EAAmB,EAAE;YAC/F,MAAM,OAAO,GAAG,IAAI,CAAC;YAErB,IAAI,CAAC,cAAc,GAAG,CAAC,OAAe,EAAE,EAAE;gBACtC,eAAe,CAAC,QAAQ,CAAC,iBAAiB,CAAC,eAAe,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;YACpF,CAAC;YAED,IAAI,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;oBAChE,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;wBAClB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;oBAC5B,CAAC;oBACD,IAAI,CAAC,UAAU,GAAG,MAAM,gBAAM,EAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,OAAO,EAAE;wBAC5D,OAAO,EAAE,CAAC,EAAE,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAE,EAAE;4BACjD,IAAI,CAAC,eAAe,CAAC,EAAE,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;wBAClD,CAAC;qBACJ,CAAC,CAAC;gBACP,CAAC;YACL,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACT,IAAI,CAAC,UAAU,GAAG,MAAM,gBAAM,EAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACnD,CAAC;YAED,OAAO,aAAa,IAAI,CAAC,MAAM,SAAS,CAAC;QAC7C,CAAC;QAEM,cAAS,GAAG,CAAO,MAAc,EAA4B,EAAE;YAClE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,IAAI,CAAC,UAAU,GAAG,MAAM,gBAAM,EAAC,MAAM,CAAC,CAAC;YAC3C,CAAC;YAED,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;YAElC,IAAI,aAAa,GAAG,CAAC,IAAmB,EAAY,EAAE;gBAClD,IAAI,KAAK,GAAa,EAAE,CAAC;gBACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACnC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxB,CAAC;gBACD,OAAO,KAAK,CAAC;YACjB,CAAC;YACD,MAAM,MAAM,GAAmB;gBAC3B,OAAO,EAAE,SAAS,CAAC,OAAO;gBAC1B,UAAU,EAAE,aAAa,CAAC,SAAS,CAAC,gBAAgB,CAAC;aACxD,CAAC;YAEF,OAAO,MAAM,CAAC;QAClB,CAAC;QAEM,aAAQ,GAAG,CAAM,MAAc,EAAmB,EAAE;YACvD,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBAClB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;YAC5B,CAAC;YAED,MAAM,kBAAQ,EAAC,MAAM,CAAC,CAAC;YAEvB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;YAE5B,OAAO,gBAAgB,MAAM,mBAAmB,CAAC;QACrD,CAAC;QAEM,cAAS,GAAG,CAAO,MAAoB,EAAmB,EAAE;YAC/D,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC;YAChC,IAAI,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC;YAE7B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;YAC5D,MAAM,WAAW,GAAG,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YAE3C,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;YAE3D,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;gBACvB,MAAM,WAAW,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC/C,MAAM,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YAEtC,MAAM,EAAE,CAAC,IAAI,CAAC;YACd,OAAO,4BAA4B,MAAM,EAAE,CAAC;QAChD,CAAC;QAEM,iBAAY,GAAG,CAAO,MAAoB,EAAmB,EAAE;YAClE,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC;YAEhC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;YAC5D,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;gBACvB,MAAM,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC3D,MAAM,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAElD,MAAM,EAAE,CAAC,IAAI,CAAC;YACd,OAAO,0BAA0B,MAAM,EAAE,CAAC;QAC9C,CAAC;QAEM,eAAU,GAAG,CAAO,SAAiB,EAAgB,EAAE;YAC1D,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;YAC9D,MAAM,OAAO,GAAG,MAAM,EAAE,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE,CAAC;YACzD,MAAM,EAAE,CAAC,IAAI,CAAC;YAEd,OAAO,OAAO,CAAC;QACnB,CAAC;QAEM,eAAU,GAAG,CAAO,SAAiB,EAAmB,EAAE;YAC7D,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;YAC/D,MAAM,EAAE,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,CAAC;YACxC,MAAM,EAAE,CAAC,IAAI,CAAC;YAEd,OAAO,SAAS,SAAS,UAAU,CAAC;QACxC,CAAC;QAEM,qBAAgB,GAAG,CAAO,UAAwB,EAAgB,EAAE;YACvE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;YACzE,MAAM,OAAO,GAAG,MAAM,EAAE,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,CAAC;iBACrD,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC;iBAC3B,GAAG,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;YAEhC,MAAM,EAAE,CAAC,IAAI,CAAC;YACd,OAAO,OAAO,CAAC;QACnB,CAAC;QAEM,yBAAoB,GAAG,CAAO,UAAwB,EAAgB,EAAE;YAC3E,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;YACzE,MAAM,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;YAC/E,IAAI,OAAO,GAAU,EAAE,CAAC;YAGxB,IAAI,MAAM,GAAG,MAAM,KAAK,CAAC,UAAU,EAAE,CAAC;YACtC,OAAO,MAAM,EAAE,CAAC;gBACZ,IAAI,MAAM,CAAC,GAAG,KAAK,UAAU,CAAC,UAAU,EAAE,CAAC;oBACvC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBAC/B,CAAC;gBACD,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,EAAE,CAAC;YACrC,CAAC;YAED,MAAM,EAAE,CAAC,IAAI,CAAC;YACd,OAAO,OAAO,CAAC;QACnB,CAAC;QAEM,kBAAa,GAAG,CAAO,SAAiB,EAAE,EAAO,EAAgB,EAAE;YACtE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;YAC9D,IAAI,MAAM,GAAG,MAAM,EAAE,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YACrD,MAAM,EAAE,CAAC,IAAI,CAAC;YACd,OAAO,MAAM,CAAC;QAClB,CAAC;QAEM,iBAAY,GAAG,CAAO,SAAiB,EAAE,EAAO,EAAmB,EAAE;YACxE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;YAC/D,MAAM,EAAE,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAC3C,MAAM,EAAE,CAAC,IAAI,CAAC;YAEd,OAAO,mBAAmB,EAAE,UAAU,CAAC;QAC3C,CAAC;IAnLe,CAAC;IAsLT,eAAe,CAAC,WAAgD,EAAE,IAAS;QAC/E,IAAI,CAAC,WAAW,CAAC,aAAa,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;YACrD,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,IAAI,OAAO,WAAW,CAAC,OAAO,KAAK,QAAQ,EAAE,CAAC;YAC1C,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,MAAM,OAAO,GAAG,WAAW,CAAC,OAAiB,CAAC;QAE9C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;YACjB,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC;QACzB,CAAC;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,eAAe,CAAC,EAAgB,EAAE,UAAkB,EAAE,OAAiB;QAC3E,IAAI,UAAU,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;YAC/B,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;gBACjB,KAAK,IAAI,KAAK,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;oBAC/B,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC;wBAC5C,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;wBAC5B,IAAI,CAAC,cAAc,CAAC,eAAe,KAAK,CAAC,IAAI,iBAAiB,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;oBACrF,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;IAEO,WAAW,CAAC,EAAgB,EAAE,KAAmB;QACrD,IAAI,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC;QAElC,IAAI,CAAC,UAAU,EAAE,CAAC;YACd,UAAU,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;QAC3D,CAAC;QAED,MAAM,QAAQ,GAAG,EAAE,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,OAAO,EAAE,UAAU,CAAC,OAAO,EAAE,aAAa,EAAE,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;QAEnH,KAAK,IAAI,KAAK,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;YAC9B,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,OAAO,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;QAC9E,CAAC;IACL,CAAC;CACJ;AAtOD,4CAsOC;;;;;;;;;;;;;;;;;;AC1OD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAyC,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAEyC;;;;;;;UChT1C;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNA,sGAAqD;AAErD,IAAU,OAAO,CAmBhB;AAnBD,WAAU,OAAO;IACb,MAAM,mBAAmB,GAAW,WAAW,CAAC;IAChD,MAAM,eAAe,GAAG;QACpB,gBAAgB,EAAE,IAAI,kCAAgB,EAAE;KAC3C,CAAC;IAEF,SAAgB,UAAU;QACtB,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,EAAE,CAAC;YAChE,MAAM,CAAC,mBAAmB,CAAC,qBACpB,eAAe,CACrB,CAAC;QACN,CAAC;aAAM,CAAC;YACJ,MAAM,CAAC,mBAAmB,CAAC,mCACpB,MAAM,CAAC,mBAAmB,CAAC,GAC3B,eAAe,CACrB,CAAC;QACN,CAAC;IAEL,CAAC;IAZe,kBAAU,aAYzB;AACL,CAAC,EAnBS,OAAO,KAAP,OAAO,QAmBhB;AAED,OAAO,CAAC,UAAU,EAAE,CAAC","sources":["webpack://indexeddbblazor.js/./client/indexedDbBlazor.ts","webpack://indexeddbblazor.js/./node_modules/idb/build/index.js","webpack://indexeddbblazor.js/webpack/bootstrap","webpack://indexeddbblazor.js/webpack/runtime/define property getters","webpack://indexeddbblazor.js/webpack/runtime/hasOwnProperty shorthand","webpack://indexeddbblazor.js/webpack/runtime/make namespace object","webpack://indexeddbblazor.js/./client/InitialiseIndexDbBlazor.ts"],"sourcesContent":["///// <reference path=\"Microsoft.JSInterop.d.ts\"/>\r\nimport { openDB, deleteDB, DBSchema, IDBPDatabase, IDBPTransaction, IDBPObjectStore } from 'idb';\r\nimport { IDbStore, IIndexSearch, IIndexSpec, IStoreRecord, IStoreSchema, IDotNetInstanceWrapper, IDbInformation } from './InteropInterfaces';\r\n\r\nexport class IndexedDbManager {\r\n\r\n    private dbInstance: IDBPDatabase<any> | undefined = undefined;\r\n    private dotnetCallback = (message: string) => { };\r\n\r\n    constructor() { }\r\n\r\n    public openDb = async (data: IDbStore, instanceWrapper: IDotNetInstanceWrapper): Promise<string> => {\r\n        const dbStore = data;\r\n        //just a test for the moment\r\n        this.dotnetCallback = (message: string) => {\r\n            instanceWrapper.instance.invokeMethodAsync(instanceWrapper.methodName, message);\r\n        }\r\n\r\n        try {\r\n            if (!this.dbInstance || this.dbInstance.version < dbStore.version) {\r\n                if (this.dbInstance) {\r\n                    this.dbInstance.close();\r\n                }\r\n                this.dbInstance = await openDB(dbStore.dbName, dbStore.version, {\r\n                    upgrade: (db, oldVersion, newVersion, transaction) => {\r\n                        this.upgradeDatabase(db, oldVersion, dbStore);\r\n                    }\r\n                });\r\n            }\r\n        } catch (e) {\r\n            this.dbInstance = await openDB(dbStore.dbName);\r\n        }\r\n        \r\n        return `IndexedDB ${data.dbName} opened`;\r\n    }\r\n\r\n    public getDbInfo = async (dbName: string) : Promise<IDbInformation> => {\r\n        if (!this.dbInstance) {\r\n            this.dbInstance = await openDB(dbName);\r\n        }\r\n\r\n        const currentDb = this.dbInstance;\r\n\r\n        let getStoreNames = (list: DOMStringList): string[] => {\r\n            let names: string[] = [];\r\n            for (var i = 0; i < list.length; i++) {\r\n                names.push(list[i]);\r\n            }\r\n            return names;\r\n        }\r\n        const dbInfo: IDbInformation = {\r\n            version: currentDb.version,\r\n            storeNames: getStoreNames(currentDb.objectStoreNames)\r\n        };\r\n\r\n        return dbInfo;\r\n    }\r\n\r\n    public deleteDb = async(dbName: string): Promise<string> => {\r\n        if (this.dbInstance) {\r\n            this.dbInstance.close();\r\n        }\r\n\r\n        await deleteDB(dbName);\r\n\r\n        this.dbInstance = undefined;\r\n\r\n        return `The database ${dbName} has been deleted`;\r\n    }\r\n\r\n    public addRecord = async (record: IStoreRecord): Promise<string> => {\r\n        const stName = record.storename;\r\n        let itemToSave = record.data;\r\n        \r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(stName, 'readwrite');\r\n        const objectStore = tx.objectStore(stName);\r\n\r\n        itemToSave = this.checkForKeyPath(objectStore, itemToSave);\r\n\r\n        const result = record.key ? \r\n            await objectStore.add(itemToSave, record.key) : \r\n            await objectStore.add(itemToSave);\r\n\r\n        await tx.done;\r\n        return `Added new record with id ${result}`;\r\n    }\r\n\r\n    public updateRecord = async (record: IStoreRecord): Promise<string> => {\r\n        const stName = record.storename;\r\n        \r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(stName, 'readwrite');\r\n        const result = record.key ? \r\n            await tx.objectStore(stName).put(record.data, record.key) : \r\n            await tx.objectStore(stName).put(record.data);\r\n        \r\n        await tx.done;\r\n        return `updated record with id ${result}`;\r\n    }\r\n\r\n    public getRecords = async (storeName: string): Promise<any> => {\r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(storeName, 'readonly');\r\n        const results = await tx.objectStore(storeName).getAll();\r\n        await tx.done;\r\n\r\n        return results;\r\n    }\r\n\r\n    public clearStore = async (storeName: string): Promise<string> => {\r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(storeName, 'readwrite');\r\n        await tx.objectStore(storeName).clear();\r\n        await tx.done;\r\n\r\n        return `Store ${storeName} cleared`;\r\n    }\r\n\r\n    public getRecordByIndex = async (searchData: IIndexSearch): Promise<any> => {\r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(searchData.storename, 'readonly');\r\n        const results = await tx.objectStore(searchData.storename)\r\n            .index(searchData.indexName)\r\n            .get(searchData.queryValue);\r\n\r\n        await tx.done;\r\n        return results;\r\n    }\r\n\r\n    public getAllRecordsByIndex = async (searchData: IIndexSearch): Promise<any> => {\r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(searchData.storename, 'readonly');\r\n        const index = tx.objectStore(searchData.storename).index(searchData.indexName);\r\n        let results: any[] = [];\r\n\r\n        // Using async iteration instead of iterateCursor (which was removed in idb 4.x)\r\n        let cursor = await index.openCursor();\r\n        while (cursor) {\r\n            if (cursor.key === searchData.queryValue) {\r\n                results.push(cursor.value);\r\n            }\r\n            cursor = await cursor.continue();\r\n        }\r\n\r\n        await tx.done;\r\n        return results;\r\n    }\r\n\r\n    public getRecordById = async (storename: string, id: any): Promise<any> => {\r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(storename, 'readonly');\r\n        let result = await tx.objectStore(storename).get(id);\r\n        await tx.done;\r\n        return result;\r\n    }\r\n\r\n    public deleteRecord = async (storename: string, id: any): Promise<string> => {\r\n        if (!this.dbInstance) {\r\n            throw new Error(\"Database instance not initialized\");\r\n        }\r\n        \r\n        const tx = this.dbInstance.transaction(storename, 'readwrite');\r\n        await tx.objectStore(storename).delete(id);\r\n        await tx.done;\r\n\r\n        return `Record with id: ${id} deleted`;\r\n    }\r\n\r\n    // Currently don't support aggregate keys\r\n    private checkForKeyPath(objectStore: IDBPObjectStore<any, any, any, any>, data: any) {\r\n        if (!objectStore.autoIncrement || !objectStore.keyPath) {\r\n            return data;\r\n        }\r\n\r\n        if (typeof objectStore.keyPath !== 'string') {\r\n            return data;\r\n        }\r\n\r\n        const keyPath = objectStore.keyPath as string;\r\n\r\n        if (!data[keyPath]) {\r\n            delete data[keyPath];\r\n        }\r\n        return data;\r\n    }\r\n\r\n    private upgradeDatabase(db: IDBPDatabase, oldVersion: number, dbStore: IDbStore) {\r\n        if (oldVersion < dbStore.version) {\r\n            if (dbStore.stores) {\r\n                for (var store of dbStore.stores) {\r\n                    if (!db.objectStoreNames.contains(store.name)) {\r\n                        this.addNewStore(db, store);\r\n                        this.dotnetCallback(`store added ${store.name}: db version: ${dbStore.version}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private addNewStore(db: IDBPDatabase, store: IStoreSchema) {\r\n        let primaryKey = store.primaryKey;\r\n\r\n        if (!primaryKey) {\r\n            primaryKey = { name: 'id', keyPath: 'id', auto: true };\r\n        }\r\n\r\n        const newStore = db.createObjectStore(store.name, { keyPath: primaryKey.keyPath, autoIncrement: primaryKey.auto });\r\n\r\n        for (var index of store.indexes) {\r\n            newStore.createIndex(index.name, index.keyPath, { unique: index.unique });\r\n        }\r\n    }\r\n}","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { IndexedDbManager } from './indexedDbBlazor';\r\n\r\nnamespace IndexDb {\r\n    const timeghostExtensions: string = 'TimeGhost';\r\n    const extensionObject = {\r\n        IndexedDbManager: new IndexedDbManager()\r\n    };\r\n\r\n    export function initialise(): void {\r\n        if (typeof window !== 'undefined' && !window[timeghostExtensions]) {\r\n            window[timeghostExtensions] = {\r\n                ...extensionObject\r\n            };\r\n        } else {\r\n            window[timeghostExtensions] = {\r\n                ...window[timeghostExtensions],\r\n                ...extensionObject\r\n            };\r\n        }\r\n\r\n    }\r\n}\r\n\r\nIndexDb.initialise();"],"names":[],"sourceRoot":""}